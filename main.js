/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GeminiPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// GeminiView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_GEMINI = "gemini-view";
var GeminiView = class extends import_obsidian.ItemView {
  constructor(leaf, service, plugin) {
    super(leaf);
    this.service = service;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_GEMINI;
  }
  getDisplayText() {
    return "Gemini Assistant";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("gemini-view-container");
    const messageContainer = container.createDiv({ cls: "gemini-messages" });
    const inputContainer = container.createDiv({ cls: "gemini-input-area" });
    const optionsContainer = container.createDiv({ cls: "gemini-options" });
    optionsContainer.style.marginBottom = "5px";
    optionsContainer.style.fontSize = "0.8em";
    optionsContainer.style.color = "var(--text-muted)";
    const contextLabel = optionsContainer.createEl("label");
    contextLabel.style.display = "flex";
    contextLabel.style.alignItems = "center";
    contextLabel.style.gap = "5px";
    const contextCheckbox = contextLabel.createEl("input", { type: "checkbox" });
    contextLabel.appendText("Include active note context");
    const inputEl = inputContainer.createEl("textarea", {
      attr: { placeholder: "Ask Gemini...", rows: "1" }
    });
    inputEl.addEventListener("input", () => {
      inputEl.style.height = "auto";
      inputEl.style.height = inputEl.scrollHeight + "px";
    });
    const sendBtn = inputContainer.createEl("button", { text: "Send" });
    const sendMessage = async () => {
      var _a;
      const prompt = inputEl.value;
      if (!prompt.trim())
        return;
      this.addMessage(messageContainer, "User", prompt);
      inputEl.value = "";
      let finalPrompt = prompt;
      const mentionRegex = /@(\w+)(?:\/([^\s]+)|:(#\w+))?/g;
      const mentions = [];
      let match;
      let cleanedPrompt = prompt;
      while ((match = mentionRegex.exec(prompt)) !== null) {
        const type = match[1];
        const path = match[2];
        const tag = match[3];
        mentions.push({ type, path, tag });
        cleanedPrompt = cleanedPrompt.replace(match[0], "").trim();
      }
      let allFiles = this.app.vault.getMarkdownFiles();
      let scopeDescription = "entire vault";
      if (mentions.length > 0) {
        const mention = mentions[0];
        if (mention.type === "NoteActuelle" || mention.type === "CurrentNote") {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (activeView && activeView.file) {
            allFiles = [activeView.file];
            scopeDescription = `current note (${activeView.file.basename})`;
          }
        } else if (mention.type === "Dossier" || mention.type === "Folder") {
          if (mention.path) {
            allFiles = allFiles.filter((file) => file.path.startsWith(mention.path));
            scopeDescription = `folder "${mention.path}"`;
          }
        } else if (mention.type === "Tag") {
          if (mention.tag) {
            allFiles = allFiles.filter((file) => {
              const cache = this.app.metadataCache.getFileCache(file);
              if (!cache || !cache.tags)
                return false;
              return cache.tags.some((t) => t.tag === mention.tag);
            });
            scopeDescription = `notes with tag ${mention.tag}`;
          }
        }
        new import_obsidian.Notice(`\u{1F3AF} Searching in: ${scopeDescription}`);
      }
      const noteTitles = allFiles.map((file) => file.basename);
      const mocTitles = noteTitles.filter((title) => title.startsWith("MOC_"));
      console.log(`Smart Linking: Found ${noteTitles.length} notes and ${mocTitles.length} MOCs in scope: ${scopeDescription}.`);
      let relevantNotesContext = "";
      const retrievalQuery = cleanedPrompt || prompt;
      if (prompt.length > 5) {
        const retrievalPrompt = `
You are a retrieval assistant for a personal knowledge base.
USER QUERY: "${retrievalQuery}"

LIST OF ALL NOTE TITLES:
${JSON.stringify(noteTitles)}

TASK:
1. Analyze the user's query.
2. Scan the list of titles to find notes that are SEMANTICALLY RELEVANT to the query.
3. Select up to 3 titles that might contain the answer.
4. **PRIORITY**: Look for SPECIFIC notes that likely contain the content (e.g., "Popcorn Recipe") rather than broad categories or MOCs (e.g., "MOC_Cuisine") unless the specific note is missing.
5. CRITICAL: You MUST return ONLY titles that EXACTLY match entries in the provided list. Do not invent titles.
6. Return ONLY a JSON array of strings. Example: ["Note A", "Note B"]
7. If no notes are relevant, return [].
`;
        let targetNotes = [];
        try {
          const loadingDiv2 = messageContainer.createDiv({ cls: "gemini-loading" });
          loadingDiv2.createSpan({ text: "\u{1F50D} Searching your vault..." });
          messageContainer.scrollTop = messageContainer.scrollHeight;
          const retrievalResponse = await this.service.generateContent(retrievalPrompt);
          loadingDiv2.remove();
          const jsonMatch = retrievalResponse.match(/\[.*\]/s);
          if (jsonMatch) {
            const rawNotes = JSON.parse(jsonMatch[0]);
            targetNotes = rawNotes.filter((t) => noteTitles.includes(t));
            console.log("Smart Retrieval (Raw):", rawNotes);
            console.log("Smart Retrieval (Validated):", targetNotes);
          }
        } catch (err) {
          console.error("Smart Retrieval failed:", err);
        }
        if (targetNotes.length === 0) {
          console.log("Smart Retrieval yielded no results. Trying Keyword Scoring...");
          const keywords = prompt.split(" ").filter((w) => w.length > 3).map((w) => w.toLowerCase());
          if (keywords.length > 0) {
            const scoredNotes = noteTitles.map((title) => {
              const titleLower = title.toLowerCase();
              let score = 0;
              keywords.forEach((k) => {
                if (titleLower.includes(k))
                  score++;
                if (titleLower === k)
                  score += 2;
              });
              return { title, score };
            });
            targetNotes = scoredNotes.filter((n) => n.score > 0).sort((a, b) => b.score - a.score).slice(0, 3).map((n) => n.title);
          }
        }
        if (targetNotes.length > 0) {
          const relevantFiles = allFiles.filter((file) => targetNotes.includes(file.basename));
          if (relevantFiles.length > 0) {
            relevantNotesContext = "\nRELEVANT NOTES CONTENT (Found by Smart Retrieval):\n";
            for (const file of relevantFiles) {
              try {
                const content = await this.app.vault.cachedRead(file);
                const truncatedContent = content.slice(0, 1500);
                relevantNotesContext += `--- Note: ${file.basename} ---
${truncatedContent}
...
`;
              } catch (err) {
                console.error(`Failed to read note ${file.basename}`, err);
              }
            }
            new import_obsidian.Notice(`\u{1F9E0} Read ${relevantFiles.length} notes for context.`);
            this.addMessage(messageContainer, "System", `\u{1F4DA} Context found in: **[[${relevantFiles.map((f) => f.basename).join("]], [[")}]]**`);
          }
        }
      }
      new import_obsidian.Notice(`Smart Linking: ${noteTitles.length} notes indexed.`);
      let activeContext = "";
      if (contextCheckbox.checked) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView) {
          const noteContent = activeView.getViewData();
          const noteTitle = ((_a = activeView.file) == null ? void 0 : _a.basename) || "Current Note";
          activeContext = `
CONTEXT FROM ACTIVE NOTE "${noteTitle}":
${noteContent}
`;
          new import_obsidian.Notice(`Included context from "${noteTitle}"`);
        }
      }
      finalPrompt = `
${this.plugin.settings.systemPrompt}

USER REQUEST:
"${prompt}"

${activeContext}

${relevantNotesContext}

---
TASK:
1. Answer the user's request above clearly and concisely.
2. **SMART LINKING (CRITICAL)**:
   - I have provided a list of ALL existing notes in this vault below (JSON).
   - **GOAL**: Connect this new note to EXISTING knowledge.
   - **INLINE LINKS**: Only create inline links [[Title]] if a term in your text EXACTLY matches a note title. DO NOT link common words (like "fait", "le", "test") even if they exist as notes.
   - **RELATED NOTES SECTION**: At the very end of your response, add a section called "### Notes Li\xE9es :" and list **UP TO 5** existing notes from the provided list.
     - **QUALITY OVER QUANTITY**: Only include notes that have a **STRONG** semantic connection (Relevance Score > 8/10).
     - If only 1 or 2 notes are relevant, ONLY list those. Do NOT force 5 links if they are not relevant.
     - **MOC PRIORITY**: You MUST check the "LIST OF MOCs" below. Identify the ONE most relevant Map of Content (MOC) for this note and link it first.
     - **CRITICAL**: Look for PARENT CONCEPTS or CATEGORIES.
     - Example: If you write about "Popcorn" and the list contains "Cuisine" or "Corn", YOU MUST LINK THEM in this section: [[Cuisine]], [[Corn]].

LIST OF MOCs (Map of Content):
${JSON.stringify(mocTitles)}

LIST OF ALL EXISTING NOTES (JSON):
${JSON.stringify(noteTitles)}
`;
      console.log("Final Prompt sent to Gemini:", finalPrompt);
      const loadingDiv = messageContainer.createDiv({ cls: "gemini-loading" });
      const spinner = loadingDiv.createDiv({ cls: "gemini-spinner" });
      loadingDiv.createSpan({ text: "Gemini is thinking..." });
      messageContainer.scrollTop = messageContainer.scrollHeight;
      try {
        const response = await this.service.generateContent(finalPrompt);
        loadingDiv.remove();
        this.addMessage(messageContainer, "Gemini", response);
      } catch (error) {
        loadingDiv.remove();
        new import_obsidian.Notice("Error communicating with Gemini. Check console/settings.");
        this.addMessage(messageContainer, "System", "Error: " + error.message);
      }
    };
    sendBtn.addEventListener("click", sendMessage);
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }
  async addMessage(container, sender, text) {
    const msgDiv = container.createDiv({ cls: "gemini-message" });
    if (sender === "User") {
      msgDiv.addClass("is-user");
    } else if (sender === "Gemini") {
      msgDiv.addClass("is-bot");
    } else {
      msgDiv.addClass("is-system");
    }
    const header = msgDiv.createDiv({ cls: "message-header" });
    header.createEl("strong", { text: sender });
    const content = msgDiv.createDiv({ cls: "message-content" });
    const component = new import_obsidian.Component();
    component.load();
    const sourcePath = "/";
    if (sender !== "System") {
      await import_obsidian.MarkdownRenderer.render(this.app, text, content, sourcePath, component);
    } else {
      await import_obsidian.MarkdownRenderer.render(this.app, text, content, sourcePath, component);
    }
    this.addChild(component);
    if (sender === "Gemini") {
      const actions = msgDiv.createDiv({ cls: "message-actions" });
      const saveBtn = actions.createEl("button", { text: "Save as Note", cls: "mod-cta" });
      saveBtn.addEventListener("click", async () => {
        try {
          const fileName = `Gemini Note ${Date.now()}.md`;
          const dateStr = new Date().toLocaleString();
          let template = this.plugin.settings.noteTemplate;
          template = template.replace("{{DATE}}", dateStr);
          template = template.replace("{{CONTENT}}", text);
          await this.app.vault.create(fileName, template);
          new import_obsidian.Notice(`Saved as ${fileName}`);
          const file = this.app.vault.getAbstractFileByPath(fileName);
          if (file) {
            this.app.workspace.getLeaf().openFile(file);
          }
        } catch (err) {
          new import_obsidian.Notice("Error saving note: " + err.message);
          console.error(err);
        }
      });
    }
    msgDiv.scrollIntoView({ behavior: "smooth", block: "end" });
  }
  async onClose() {
  }
};

// Settings.ts
var import_obsidian2 = require("obsidian");
var GeminiSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Gemini Assistant" });
    new import_obsidian2.Setting(containerEl).setName("Gemini API Key").setDesc("Enter your Google Gemini API Key").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("System Prompt").setDesc("Customize the behavior and persona of the AI.").addTextArea((text) => text.setPlaceholder("Enter system prompt...").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
      this.plugin.settings.systemPrompt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Note Template").setDesc('Template for "Save as Note". Use {{CONTENT}} for the AI response and {{DATE}} for current date.').addTextArea((text) => text.setPlaceholder("Enter note template...").setValue(this.plugin.settings.noteTemplate).onChange(async (value) => {
      this.plugin.settings.noteTemplate = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Autocomplete (Ghost Text)" });
    new import_obsidian2.Setting(containerEl).setName("Enable Autocomplete").setDesc("Show AI-powered suggestions as you type (like Copilot).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutocomplete).onChange(async (value) => {
      this.plugin.settings.enableAutocomplete = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Autocomplete Delay (ms)").setDesc("Wait time before requesting suggestion (default: 600ms).").addSlider((slider) => slider.setLimits(300, 2e3, 100).setValue(this.plugin.settings.autocompleteDelay).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autocompleteDelay = value;
      await this.plugin.saveSettings();
    }));
  }
};

// node_modules/@google/generative-ai/dist/index.mjs
var SchemaType;
(function(SchemaType2) {
  SchemaType2["STRING"] = "string";
  SchemaType2["NUMBER"] = "number";
  SchemaType2["INTEGER"] = "integer";
  SchemaType2["BOOLEAN"] = "boolean";
  SchemaType2["ARRAY"] = "array";
  SchemaType2["OBJECT"] = "object";
})(SchemaType || (SchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var POSSIBLE_ROLES = ["user", "model", "function", "system"];
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
var DynamicRetrievalMode;
(function(DynamicRetrievalMode2) {
  DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));
var GoogleGenerativeAIError = class extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
};
var GoogleGenerativeAIResponseError = class extends GoogleGenerativeAIError {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
};
var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
};
var GoogleGenerativeAIAbortError = class extends GoogleGenerativeAIError {
};
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.24.1";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
var RequestUrl = class {
  constructor(model, task, apiKey, stream, requestOptions) {
    this.model = model;
    this.task = task;
    this.apiKey = apiKey;
    this.stream = stream;
    this.requestOptions = requestOptions;
  }
  toString() {
    var _a, _b;
    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
    if (this.stream) {
      url += "?alt=sse";
    }
    return url;
  }
};
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  var _a;
  const headers = new Headers();
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
  const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
  return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (err.name === "AbortError") {
    err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json = await response.json();
    message = json.error.message;
    if (json.error.details) {
      message += ` ${JSON.stringify(json.error.details)}`;
      errorDetails = json.error.details;
    }
  } catch (e) {
  }
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const controller = new AbortController();
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    fetchOptions.signal = controller.signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  return response;
}
function getText(response) {
  var _a, _b, _c, _d;
  const textStrings = [];
  if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
      if (part.executableCode) {
        textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
      }
      if (part.codeExecutionResult) {
        textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a, _b, _c, _d;
  const functionCalls = [];
  if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return void 0;
  }
}
var badFinishReasons = [
  FinishReason.RECITATION,
  FinishReason.SAFETY,
  FinishReason.LANGUAGE
];
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a, _b, _c;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value;
          let match = currentText.match(responseLineRE);
          let parsedResponse;
          while (match) {
            try {
              parsedResponse = JSON.parse(match[1]);
            } catch (e) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match[0].length);
            match = currentText.match(responseLineRE);
          }
          return pump();
        }).catch((e) => {
          let err = e;
          err.stack = e.stack;
          if (err.name === "AbortError") {
            err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
          } else {
            err = new GoogleGenerativeAIError("Error reading from the stream");
          }
          throw err;
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      let candidateIndex = 0;
      for (const candidate of response.candidates) {
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[candidateIndex]) {
          aggregatedResponse.candidates[candidateIndex] = {
            index: candidateIndex
          };
        }
        aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
        aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[candidateIndex].content) {
            aggregatedResponse.candidates[candidateIndex].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (part.executableCode) {
              newPart.executableCode = part.executableCode;
            }
            if (part.codeExecutionResult) {
              newPart.codeExecutionResult = part.codeExecutionResult;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
          }
        }
      }
      candidateIndex++;
    }
    if (response.usageMetadata) {
      aggregatedResponse.usageMetadata = response.usageMetadata;
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.STREAM_GENERATE_CONTENT,
    apiKey,
    /* stream */
    true,
    JSON.stringify(params),
    requestOptions
  );
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.GENERATE_CONTENT,
    apiKey,
    /* stream */
    false,
    JSON.stringify(params),
    requestOptions
  );
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return void 0;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request) {
  let newParts = [];
  if (typeof request === "string") {
    newParts = [{ text: request }];
  } else {
    for (const partOrString of request) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatCountTokensInput(params, modelParams) {
  var _a;
  let formattedGenerateContentRequest = {
    model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
    generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
    safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
    tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
    toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
    systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
    cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,
    contents: []
  };
  const containsGenerateContentRequest = params.generateContentRequest != null;
  if (params.contents) {
    if (containsGenerateContentRequest) {
      throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    }
    formattedGenerateContentRequest.contents = params.contents;
  } else if (containsGenerateContentRequest) {
    formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
  } else {
    const content = formatNewContent(params);
    formattedGenerateContentRequest.contents = [content];
  }
  return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
var VALID_PART_FIELDS = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
];
var VALID_PARTS_PER_ROLE = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  // System instructions shouldn't be in history anyway.
  system: ["text"]
};
function validateChatHistory(history) {
  let prevContent = false;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    prevContent = true;
  }
}
function isValidResponse(response) {
  var _a;
  if (response.candidates === void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
  if (content === void 0) {
    return false;
  }
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
    if (part.text !== void 0 && part.text === "") {
      return false;
    }
  }
  return true;
}
var SILENT_ERROR = "SILENT_ERROR";
var ChatSession = class {
  constructor(apiKey, model, params, _requestOptions = {}) {
    this.model = model;
    this.params = params;
    this._requestOptions = _requestOptions;
    this._history = [];
    this._sendPromise = Promise.resolve();
    this._apiKey = apiKey;
    if (params === null || params === void 0 ? void 0 : params.history) {
      validateChatHistory(params.history);
      this._history = params.history;
    }
  }
  /**
   * Gets the chat history so far. Blocked prompts are not added to history.
   * Blocked candidates are not added to history, nor are the prompts that
   * generated them.
   */
  async getHistory() {
    await this._sendPromise;
    return this._history;
  }
  /**
   * Sends a chat message and receives a non-streaming
   * {@link GenerateContentResult}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessage(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    let finalResult;
    this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
      var _a2;
      if (isValidResponse(result.response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({
          parts: [],
          // Response seems to come back without a role set.
          role: "model"
        }, (_a2 = result.response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0].content);
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(result.response);
        if (blockErrorMessage) {
          console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
      finalResult = result;
    }).catch((e) => {
      this._sendPromise = Promise.resolve();
      throw e;
    });
    await this._sendPromise;
    return finalResult;
  }
  /**
   * Sends a chat message and receives the response as a
   * {@link GenerateContentStreamResult} containing an iterable stream
   * and a response promise.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessageStream(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
    this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
      throw new Error(SILENT_ERROR);
    }).then((streamResult) => streamResult.response).then((response) => {
      if (isValidResponse(response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({}, response.candidates[0].content);
        if (!responseContent.role) {
          responseContent.role = "model";
        }
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(response);
        if (blockErrorMessage) {
          console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
    }).catch((e) => {
      if (e.message !== SILENT_ERROR) {
        console.error(e);
      }
    });
    return streamPromise;
  }
};
async function countTokens(apiKey, model, params, singleRequestOptions) {
  const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request) => {
    return Object.assign(Object.assign({}, request), { model });
  });
  const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}
var GenerativeModel = class {
  constructor(apiKey, modelParams, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
    if (modelParams.model.includes("/")) {
      this.model = modelParams.model;
    } else {
      this.model = `models/${modelParams.model}`;
    }
    this.generationConfig = modelParams.generationConfig || {};
    this.safetySettings = modelParams.safetySettings || [];
    this.tools = modelParams.tools;
    this.toolConfig = modelParams.toolConfig;
    this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
    this.cachedContent = modelParams.cachedContent;
  }
  /**
   * Makes a single non-streaming call to the model
   * and returns an object containing a single {@link GenerateContentResponse}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContent(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Makes a single streaming call to the model and returns an object
   * containing an iterable stream that iterates over all chunks in the
   * streaming response as well as a promise that returns the final
   * aggregated response.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContentStream(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Gets a new {@link ChatSession} instance which can be used for
   * multi-turn chats.
   */
  startChat(startChatParams) {
    var _a;
    return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);
  }
  /**
   * Counts the tokens in the provided request.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async countTokens(request, requestOptions = {}) {
    const formattedParams = formatCountTokensInput(request, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    });
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds the provided content.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async embedContent(request, requestOptions = {}) {
    const formattedParams = formatEmbedContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds an array of {@link EmbedContentRequest}s.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
  }
};
var GoogleGenerativeAI = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Gets a {@link GenerativeModel} instance for the provided model name.
   */
  getGenerativeModel(modelParams, requestOptions) {
    if (!modelParams.model) {
      throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
    }
    return new GenerativeModel(this.apiKey, modelParams, requestOptions);
  }
  /**
   * Creates a {@link GenerativeModel} instance from provided content cache.
   */
  getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
    if (!cachedContent.name) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
    }
    if (!cachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    const disallowedDuplicates = ["model", "systemInstruction"];
    for (const key of disallowedDuplicates) {
      if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
        if (key === "model") {
          const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
          const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
          if (modelParamsComp === cachedContentComp) {
            continue;
          }
        }
        throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
      }
    }
    const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
    return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
  }
};

// GeminiService.ts
var GeminiService = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.init();
  }
  init() {
    if (!this.apiKey || this.apiKey === "default") {
      console.warn("Gemini API Key not set");
      return;
    }
    this.genAI = new GoogleGenerativeAI(this.apiKey);
    this.model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
  }
  updateApiKey(apiKey) {
    this.apiKey = apiKey;
    this.init();
  }
  async generateContent(prompt) {
    if (!this.model) {
      throw new Error("Gemini API not initialized. Please check your API key in settings.");
    }
    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text();
    } catch (error) {
      console.error("Error generating content from Gemini:", error);
      if (error.toString().includes("404") || error.toString().includes("not found") || error.toString().includes("429")) {
        console.log("Primary model failed (404 or 429), trying fallback to gemini-2.0-flash-lite...");
        try {
          const fallbackModel = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash-lite" });
          const result = await fallbackModel.generateContent(prompt);
          const response = await result.response;
          return response.text();
        } catch (fallbackError) {
          console.error("Fallback model also failed:", fallbackError);
          if (fallbackError.toString().includes("429")) {
            return "\u26A0\uFE0F Quota d\xE9pass\xE9 (Erreur 429). Veuillez patienter quelques instants avant de r\xE9essayer.";
          }
          throw error;
        }
      }
      if (error.toString().includes("429")) {
        return "\u26A0\uFE0F Quota d\xE9pass\xE9 (Erreur 429). Veuillez patienter quelques instants avant de r\xE9essayer.";
      }
      throw error;
    }
  }
};

// LinkSuggestionModal.ts
var import_obsidian3 = require("obsidian");
var LinkSuggestionModal = class extends import_obsidian3.Modal {
  constructor(app, suggestions, onSubmit) {
    super(app);
    this.suggestions = suggestions;
    this.onSubmit = onSubmit;
    this.selectedSuggestions = new Set(suggestions.map((_, i) => i));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Gemini Link Suggestions" });
    if (this.suggestions.length === 0) {
      contentEl.createEl("p", { text: "No relevant links found." });
      return;
    }
    contentEl.createEl("p", { text: "Select the links you want to apply:" });
    this.suggestions.forEach((suggestion, index) => {
      new import_obsidian3.Setting(contentEl).setName(`Link "${suggestion.originalText}" to [[${suggestion.noteTitle}]]`).setDesc(suggestion.context || "").addToggle((toggle) => toggle.setValue(true).onChange((value) => {
        if (value) {
          this.selectedSuggestions.add(index);
        } else {
          this.selectedSuggestions.delete(index);
        }
      }));
    });
    new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Apply Selected Links").setCta().onClick(() => {
      const selected = this.suggestions.filter((_, i) => this.selectedSuggestions.has(i));
      this.close();
      this.onSubmit(selected);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// AtomicNotesModal.ts
var import_obsidian4 = require("obsidian");
var AtomicNotesModal = class extends import_obsidian4.Modal {
  constructor(app, notes, onSubmit) {
    super(app);
    this.notes = notes;
    this.onSubmit = onSubmit;
    this.selectedNotes = new Set(notes.map((_, i) => i));
    this.createMOC = true;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Atomic Notes Preview" });
    if (this.notes.length === 0) {
      contentEl.createEl("p", { text: "No atomic notes could be generated." });
      return;
    }
    contentEl.createEl("p", {
      text: `Gemini has identified ${this.notes.length} atomic concept(s). Select the notes you want to create:`
    });
    this.notes.forEach((note, index) => {
      const notePreview = contentEl.createDiv({ cls: "atomic-note-preview" });
      notePreview.style.marginBottom = "15px";
      notePreview.style.padding = "10px";
      notePreview.style.border = "1px solid var(--background-modifier-border)";
      notePreview.style.borderRadius = "5px";
      new import_obsidian4.Setting(notePreview).setName(`\u{1F4C4} ${note.title}`).setDesc(note.summary).addToggle((toggle) => toggle.setValue(true).onChange((value) => {
        if (value) {
          this.selectedNotes.add(index);
        } else {
          this.selectedNotes.delete(index);
        }
      }));
      const contentPreview = notePreview.createDiv({ cls: "content-preview" });
      contentPreview.style.fontSize = "0.85em";
      contentPreview.style.color = "var(--text-muted)";
      contentPreview.style.marginTop = "5px";
      contentPreview.style.fontStyle = "italic";
      const truncatedContent = note.content.slice(0, 200) + (note.content.length > 200 ? "..." : "");
      contentPreview.setText(truncatedContent);
    });
    new import_obsidian4.Setting(contentEl).setName("Create MOC (Map of Content)").setDesc("Replace the current note with a MOC linking to all created atomic notes.").addToggle((toggle) => toggle.setValue(true).onChange((value) => {
      this.createMOC = value;
    }));
    new import_obsidian4.Setting(contentEl).addButton((btn) => btn.setButtonText("Create Selected Notes").setCta().onClick(() => {
      const selected = this.notes.filter((_, i) => this.selectedNotes.has(i));
      if (selected.length === 0) {
        new import_obsidian4.Notice("No notes selected.");
        return;
      }
      this.close();
      this.onSubmit(selected, this.createMOC);
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// AutocompleteExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var setSuggestionEffect = import_state.StateEffect.define();
var GhostTextWidget = class extends import_view.WidgetType {
  constructor(text) {
    super();
    this.text = text;
  }
  toDOM() {
    const span = document.createElement("span");
    span.textContent = this.text;
    span.style.color = "var(--text-faint)";
    span.style.opacity = "0.5";
    span.style.pointerEvents = "none";
    return span;
  }
};
var suggestionTextField = import_state.StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSuggestionEffect)) {
        return effect.value;
      }
    }
    return value;
  }
});
var suggestionField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(decorations, tr) {
    decorations = decorations.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(setSuggestionEffect)) {
        if (effect.value === null) {
          decorations = import_view.Decoration.none;
        } else {
          const widget = import_view.Decoration.widget({
            widget: new GhostTextWidget(effect.value.text),
            side: 1
          });
          decorations = import_view.Decoration.set([widget.range(effect.value.from)]);
        }
      }
    }
    return decorations;
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
function debounce(func, wait) {
  let timeout = null;
  return function(...args) {
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}
function createAutocompleteExtension(service, enabled, delay) {
  let abortController = null;
  let lastRequestPos = -1;
  const autocompletePlugin = import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.scheduleRequest = debounce(this.requestCompletion.bind(this), delay());
    }
    update(update) {
      if (!enabled())
        return;
      if (update.docChanged) {
        if (abortController) {
          abortController.abort();
          abortController = null;
        }
        const cursorPos = update.state.selection.main.head;
        this.scheduleRequest(cursorPos);
      }
    }
    async requestCompletion(cursorPos) {
      if (!enabled())
        return;
      const state = this.view.state;
      const doc = state.doc;
      const textBefore = doc.sliceString(0, cursorPos);
      const textAfter = doc.sliceString(cursorPos);
      const maxBefore = 2e3;
      const maxAfter = 500;
      const limitedBefore = textBefore.slice(-maxBefore);
      const limitedAfter = textAfter.slice(0, maxAfter);
      if (limitedBefore.trim().length < 10)
        return;
      const prompt = `You are an autocomplete assistant for note-taking.
Complete the text at the cursor position <CURSOR>.

RULES:
1. Return ONLY the completion text (what comes after the cursor).
2. Do NOT repeat existing text.
3. Be concise and contextually relevant (max 1-2 sentences).
4. Match the language and tone of the surrounding text.
5. If the text after cursor already continues the thought, return nothing.

TEXT BEFORE CURSOR:
${limitedBefore}

<CURSOR>

TEXT AFTER CURSOR:
${limitedAfter}

COMPLETION:`;
      try {
        abortController = new AbortController();
        lastRequestPos = cursorPos;
        const suggestion = await service.generateContent(prompt);
        const currentPos = this.view.state.selection.main.head;
        if (currentPos !== lastRequestPos) {
          return;
        }
        const cleanSuggestion = suggestion.trim().split("\n")[0].slice(0, 200);
        if (cleanSuggestion.length > 0) {
          this.view.dispatch({
            effects: setSuggestionEffect.of({
              text: cleanSuggestion,
              from: cursorPos
            })
          });
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Autocomplete error:", error);
        }
      }
    }
    destroy() {
      if (abortController) {
        abortController.abort();
      }
    }
  });
  const acceptKeybinding = import_view.keymap.of([
    {
      key: "Tab",
      run: (view) => {
        const suggestion = view.state.field(suggestionTextField);
        if (!suggestion)
          return false;
        const cursorPos = view.state.selection.main.head;
        view.dispatch({
          changes: { from: cursorPos, insert: suggestion.text },
          effects: setSuggestionEffect.of(null)
        });
        return true;
      }
    }
  ]);
  return [suggestionTextField, suggestionField, autocompletePlugin, acceptKeybinding];
}

// main.ts
var DEFAULT_SETTINGS = {
  apiKey: "default",
  noteTemplate: `### metadata :
- Date : {{DATE}}
- Statue : #encours #perma 
- Topic :
- Links : [[...]]


## D\xE9finition :
{{CONTENT}}


## Tips : 
-####`,
  systemPrompt: `You are a helpful AI assistant integrated into Obsidian.
Your goal is to help the user manage their personal knowledge base.
Provide detailed, comprehensive, and precise responses. Use Markdown formatting.`,
  enableAutocomplete: true,
  autocompleteDelay: 600
};
var GeminiPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.service = new GeminiService(this.settings.apiKey);
    this.registerView(
      VIEW_TYPE_GEMINI,
      (leaf) => new GeminiView(leaf, this.service, this)
    );
    this.registerEditorExtension(
      createAutocompleteExtension(
        this.service,
        () => this.settings.enableAutocomplete,
        () => this.settings.autocompleteDelay
      )
    );
    const ribbonIconEl = this.addRibbonIcon("bot", "Gemini Assistant", (evt) => {
      this.activateView();
    });
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Gemini Ready");
    this.addCommand({
      id: "open-gemini-assistant",
      name: "Open Gemini Assistant",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "gemini-generate-selection",
      name: "Generate from selection",
      editorCallback: async (editor, view) => {
        const selection = editor.getSelection();
        if (!selection) {
          new import_obsidian5.Notice("Please select some text first.");
          return;
        }
        new import_obsidian5.Notice("Asking Gemini...");
        try {
          const response = await this.service.generateContent(selection);
          editor.replaceSelection(response);
        } catch (error) {
          new import_obsidian5.Notice("Error generating content.");
          console.error(error);
        }
      }
    });
    this.addCommand({
      id: "debug-gemini-models",
      name: "Debug: List Available Models",
      callback: async () => {
        const key = this.settings.apiKey;
        if (!key || key === "default") {
          new import_obsidian5.Notice("No API Key set.");
          return;
        }
        try {
          new import_obsidian5.Notice("Fetching models...");
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
          const data = await response.json();
          if (data.error) {
            console.error("API Error:", data.error);
            new import_obsidian5.Notice(`API Error: ${data.error.message}`);
          } else if (data.models) {
            console.log("Available Models:", data.models);
            const modelNames = data.models.map((m) => m.name).join("\n");
            new import_obsidian5.Notice(`Found ${data.models.length} models. Check console.`);
            console.log(modelNames);
          } else {
            new import_obsidian5.Notice("No models found or unexpected response.");
            console.log(data);
          }
        } catch (e) {
          console.error(e);
          new import_obsidian5.Notice("Network error checking models.");
        }
      }
    });
    this.addCommand({
      id: "gemini-suggest-links",
      name: "Suggest links for current paragraph",
      editorCallback: async (editor, view) => {
        const cursor = editor.getCursor();
        const lineText = editor.getLine(cursor.line);
        if (!lineText.trim()) {
          new import_obsidian5.Notice("Current line is empty.");
          return;
        }
        new import_obsidian5.Notice("Analyzing for links...");
        const allFiles = this.app.vault.getMarkdownFiles();
        const noteTitles = allFiles.map((file) => file.basename);
        const prompt = `
You are a linking assistant for Obsidian.
TEXT TO ANALYZE: "${lineText}"

LIST OF ALL NOTE TITLES:
${JSON.stringify(noteTitles)}

TASK:
1. Identify phrases in the text that correspond to existing note titles.
2. Return a JSON array of objects: { "originalText": "text in paragraph", "noteTitle": "Exact Note Title" }.
3. Only suggest links where the connection is clear.
4. Do not suggest linking common words like "the", "a", "is".
5. Example: If text is "I love popcorn" and note is "Popcorn Recipe", return [{ "originalText": "popcorn", "noteTitle": "Popcorn Recipe" }].
`;
        try {
          const response = await this.service.generateContent(prompt);
          const jsonMatch = response.match(/\[.*\]/s);
          if (jsonMatch) {
            const suggestions = JSON.parse(jsonMatch[0]);
            const validSuggestions = suggestions.filter((s) => noteTitles.includes(s.noteTitle));
            if (validSuggestions.length === 0) {
              new import_obsidian5.Notice("No relevant links found.");
              return;
            }
            new LinkSuggestionModal(this.app, validSuggestions, (selected) => {
              let newLineText = lineText;
              selected.sort((a, b) => b.originalText.length - a.originalText.length);
              selected.forEach((s) => {
                const escapedText = s.originalText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                const regex = new RegExp(escapedText, "gi");
                newLineText = newLineText.replace(regex, `[[${s.noteTitle}|${s.originalText}]]`);
              });
              editor.setLine(cursor.line, newLineText);
              new import_obsidian5.Notice(`Applied ${selected.length} links.`);
            }).open();
          } else {
            new import_obsidian5.Notice("No structured suggestions found.");
          }
        } catch (error) {
          console.error(error);
          new import_obsidian5.Notice("Error suggesting links.");
        }
      }
    });
    this.addCommand({
      id: "gemini-atomic-notes",
      name: "Refactor into Atomic Notes",
      editorCallback: async (editor, view) => {
        const currentFile = view.file;
        if (!currentFile) {
          new import_obsidian5.Notice("No active file.");
          return;
        }
        const content = editor.getValue();
        if (!content.trim()) {
          new import_obsidian5.Notice("Current note is empty.");
          return;
        }
        new import_obsidian5.Notice("\u2699\uFE0F Analyzing note structure...");
        const prompt = `
You are a Zettelkasten expert. Your task is to decompose a long note into atomic notes.

CURRENT NOTE CONTENT:
"${content}"

TASK:
1. Identify distinct atomic concepts in this text (each concept should be self-contained).
2. For each concept, extract the relevant paragraph(s) from the original text.
3. For each atomic note, create:
   - A clear, descriptive title (filename-friendly, no special chars except underscore and dash)
   - The content structured as follows:
     **First**: The original paragraph(s) extracted verbatim from the text (keep the exact wording)
     **Then**: Add a separator "---" 
     **Finally**: Add your enrichment - additional ideas, context, explanations, or related concepts in the SAME LANGUAGE as the original text
   - A brief summary (1-2 sentences)
4. Return a JSON array: [{ "title": "Note Title", "content": "## Original Text
[original paragraph]

---

## Enrichment
[your additions]", "summary": "Brief summary" }]
5. Aim for 2-5 atomic notes. Do not create more than 7.
6. Each atomic note should be focused on ONE concept or idea.
7. CRITICAL: Write your enrichment in the same language as the original text.
`;
        try {
          const response = await this.service.generateContent(prompt);
          const jsonMatch = response.match(/\[.*\]/s);
          if (!jsonMatch) {
            new import_obsidian5.Notice("Could not parse atomic notes from response.");
            return;
          }
          const atomicNotes = JSON.parse(jsonMatch[0]);
          if (atomicNotes.length === 0) {
            new import_obsidian5.Notice("No atomic concepts identified.");
            return;
          }
          new AtomicNotesModal(this.app, atomicNotes, async (selected, createMOC) => {
            try {
              const createdFiles = [];
              for (const note of selected) {
                const fileName = `${note.title}.md`;
                const filePath = fileName;
                const existingFile = this.app.vault.getAbstractFileByPath(filePath);
                if (existingFile) {
                  new import_obsidian5.Notice(`File "${fileName}" already exists. Skipping.`);
                  continue;
                }
                await this.app.vault.create(filePath, note.content);
                createdFiles.push(note.title);
              }
              new import_obsidian5.Notice(`\u2705 Created ${createdFiles.length} atomic note(s).`);
              if (createMOC && createdFiles.length > 0) {
                const originalTitle = currentFile.basename;
                const mocContent = `# MOC: ${originalTitle}

This note has been refactored into atomic concepts:

${createdFiles.map((title) => `- [[${title}]]`).join("\n")}

---
*Generated by Gemini Assistant*
`;
                await this.app.vault.modify(currentFile, mocContent);
                new import_obsidian5.Notice("\u{1F4CB} Current note transformed into MOC.");
              }
            } catch (err) {
              console.error(err);
              new import_obsidian5.Notice("Error creating atomic notes: " + err.message);
            }
          }).open();
        } catch (error) {
          console.error(error);
          new import_obsidian5.Notice("Error generating atomic notes.");
        }
      }
    });
    this.addCommand({
      id: "gemini-graph-synthesis",
      name: "Generate Graph Summary",
      editorCallback: async (editor, view) => {
        var _a, _b;
        const currentFile = view.file;
        if (!currentFile) {
          new import_obsidian5.Notice("No active file.");
          return;
        }
        new import_obsidian5.Notice("\u{1F578}\uFE0F Analyzing graph connections...");
        try {
          const centralContent = await this.app.vault.cachedRead(currentFile);
          const backlinks = (_b = (_a = this.app.metadataCache).getBacklinksForFile) == null ? void 0 : _b.call(_a, currentFile);
          const backlinkFiles = [];
          if (backlinks && backlinks.data) {
            backlinks.data.forEach((_, key) => {
              const file = this.app.vault.getAbstractFileByPath(key);
              if (file instanceof import_obsidian5.TFile) {
                backlinkFiles.push(file);
              }
            });
          }
          const cache = this.app.metadataCache.getFileCache(currentFile);
          const outgoingFiles = [];
          if (cache && cache.links) {
            cache.links.forEach((link) => {
              const linkedFile = this.app.metadataCache.getFirstLinkpathDest(link.link, currentFile.path);
              if (linkedFile) {
                outgoingFiles.push(linkedFile);
              }
            });
          }
          const allConnectedFiles = [.../* @__PURE__ */ new Set([...backlinkFiles, ...outgoingFiles])];
          if (allConnectedFiles.length === 0) {
            new import_obsidian5.Notice("No connected notes found.");
            return;
          }
          new import_obsidian5.Notice(`Found ${allConnectedFiles.length} connected note(s). Reading...`);
          const maxNotes = 10;
          const notesToRead = allConnectedFiles.slice(0, maxNotes);
          let connectedContext = "";
          for (const file of notesToRead) {
            try {
              const content = await this.app.vault.cachedRead(file);
              const truncated = content.slice(0, 1e3);
              connectedContext += `
--- Connected Note: ${file.basename} ---
${truncated}
`;
            } catch (err) {
              console.error(`Failed to read ${file.basename}`, err);
            }
          }
          const prompt = `
You are a knowledge synthesis expert.

CENTRAL NOTE: "${currentFile.basename}"
Content:
${centralContent}

CONNECTED NOTES (${notesToRead.length} notes linked to/from this central note):
${connectedContext}

TASK:
Generate a comprehensive synthesis that explains the global concept represented by this note and its network.
1. What is the central theme?
2. How do the connected notes relate to it?
3. What are the key insights from this knowledge cluster?
4. Are there any patterns or emergent ideas?

Write your synthesis in a clear, structured format using Markdown.
`;
          const synthesis = await this.service.generateContent(prompt);
          const synthesisFileName = `Graph Synthesis - ${currentFile.basename}.md`;
          const synthesisContent = `# Graph Synthesis: ${currentFile.basename}

**Generated:** ${new Date().toLocaleString()}
**Central Note:** [[${currentFile.basename}]]
**Connected Notes:** ${allConnectedFiles.length}

---

${synthesis}

---

## Connected Notes
${allConnectedFiles.map((f) => `- [[${f.basename}]]`).join("\n")}
`;
          await this.app.vault.create(synthesisFileName, synthesisContent);
          new import_obsidian5.Notice(`\u2705 Graph synthesis created: ${synthesisFileName}`);
          const synthesisFile = this.app.vault.getAbstractFileByPath(synthesisFileName);
          if (synthesisFile instanceof import_obsidian5.TFile) {
            this.app.workspace.getLeaf().openFile(synthesisFile);
          }
        } catch (error) {
          console.error(error);
          new import_obsidian5.Notice("Error generating graph synthesis.");
        }
      }
    });
    this.addSettingTab(new GeminiSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.service) {
      this.service.updateApiKey(this.settings.apiKey);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_GEMINI);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_GEMINI, active: true });
    }
    workspace.revealLeaf(leaf);
  }
};
/*! Bundled license information:

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
